var documenterSearchIndex = {"docs":
[{"location":"constructors/#Built-in-constructors","page":"Built-in Constructors","title":"Built-in constructors","text":"","category":"section"},{"location":"constructors/","page":"Built-in Constructors","title":"Built-in Constructors","text":"This section details the filter constructors included by default. These are built off of the Waveletspackage for the 1D constructors.","category":"page"},{"location":"constructors/#D-methods","page":"Built-in Constructors","title":"1D methods","text":"","category":"section"},{"location":"constructors/","page":"Built-in Constructors","title":"Built-in Constructors","text":"\nwaveletLayer","category":"page"},{"location":"constructors/#FourierFilterFlux.waveletLayer","page":"Built-in Constructors","title":"FourierFilterFlux.waveletLayer","text":"waveletLayer(inputSize::Union{Int,NTuple{N, T}};\n             dType = Float32, σ = identity, trainable = false,\n             plan = true, init = Flux.glorot_normal, bias=false,\n             convBoundary=Sym(), cw = Morlet(), averagingLayer = false,\n             varargs...) where {N,T}\n\nCreate a ConvFFT layer that uses wavelets from ContinuousWavelets.jl. By default it isn't trainable. varargs are any of the settings that can be passed on to creating a CFW type.\n\nNew Arguments\n\nconvBoundary::ConvBoundary=Sym(): the type of symmetry to use in computing                                     the transform. Note that convBoundary and                                     boundary are different, with boundary                                     needing to be set using types from                                     ContinuousWavelets and convBoundary needs                                     to be set using the FourierFilterFlux                                     boundary types.\ncw::ContWaveClass=Morlet(): the type of wavelet to use, e.g. dog2,                               Morlet(). See ContinuousWavelets.jl for more.\naveragingLayer::Bool=false: if true, use just the averaging filter, and drop all other filters.\n\nArguments from ContinuousWavelets.jl\n\nscalingFactor, s, or Q::Real=8.0: the number of wavelets between the octaves 2^J and 2^J+1 (defaults to 8, which is most appropriate for music and other audio). Valid range is (0infty).\nβ::Real=4.0: As using exactly Q wavelets per octave leads to excessively many low-frequency wavelets, β varies the number of wavelets per octave, with larger values of β corresponding to fewer low frequency wavelets(see Wavelet Frequency Spacing for details). Valid range is (1infty), though around β=6 the spacing is approximately linear in frequency, rather than log-frequency, and begins to become concave after that.\nboundary::WaveletBoundary=SymBoundary(): The default boundary condition is SymBoundary(), implemented by appending a flipped version of the vector at the end to eliminate edge discontinuities. See Boundary Conditions for the other possibilities.\naveragingType::Average=Father(): determines whether or not to include the averaging function, and if so, what kind of averaging. The options are\nFather: use the averaging function that corresponds to the mother Wavelet.\nDirac: use the sinc function with the appropriate width.\nNoAve: don't average. this has one fewer filters than the other averagingTypes\naveragingLength::Int=4:  the number of wavelet octaves that are covered by the averaging,\nframeBound::Real=1: gives the total norm of the whole collection, corresponding to the upper frame bound; if you don't want to impose a particular bound, set frameBound<0.\nnormalization or p::Real=Inf: the p-norm preserved as the scale changes, so if we're scaling by s, normalization has value p, and the mother wavelet is psi, then the resulting wavelet is s^1ppsi(^t_s). The default scaling, Inf gives all the same maximum value in the frequency domain. Valid range is (0infty, though p1 isn't actually preserving a norm.\n\n\n\n\n\n","category":"function"},{"location":"constructors/#D-methods-2","page":"Built-in Constructors","title":"2D methods","text":"","category":"section"},{"location":"coreType/#ConvFFT-type","page":"Core Type","title":"ConvFFT type","text":"","category":"section"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"The core type of this package. As a simple example in 1D:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"julia> using FourierFilterFlux, Plots, FFTW, Flux, LinearAlgebra, Random\n\njulia> Random.seed!(1234);\n\njulia> w = zeros(128,2); w[25:30,1] = randn(6);\n\njulia> w[55:60,2] = randn(6);\n\njulia> ŵ = rfft(w, 1);\n\njulia> W = ConvFFT(ŵ,nothing,(128,1,2))\nConvFFT[input=((128,), nfilters = 2, σ=identity, bc=Periodic()]\n","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"using FourierFilterFlux, Plots, FFTW, Flux, LinearAlgebra, Random # hide\nRandom.seed!(1234) # hide\nw = zeros(128,2); w[25:30,1] = randn(6)  # hide\nw[55:60,2] = randn(6) # hide\nŵ = rfft(w, 1) # hide\nW = ConvFFT(ŵ,nothing,(128,1,2))  # hide\nplot(W, title=\"Time domain Filters\", dispReal=true, apply=identity, vis=1:2)","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"So we've created two filters with small support and displayed them in the time domain (note that this has been done with a Plot Recipe). Applying this to a signal x, which is non-zero at only the two boundary locations:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"julia> x = zeros(128,1,2);\n\njulia> x[105,1,2] = 1; x[end,1,2] = -1; # positive on one side and negative on the other\n\njulia> r = W(x)\n128×2×1×2 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.0  0.0\n 0.0  0.0\n ⋮\n 0.0  0.0\n 0.0  0.0\n\n[:, :, 1, 2] =\n -0.359729     -2.08167e-17\n  1.08721      -1.38778e-17\n  ⋮\n  1.27045e-17  -1.249e-16\n -9.26904e-17  -2.77556e-17","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"x = zeros(128,1,2); # hide\nx[105,1,2] = 1; x[end,1,2] = -1; # hide\nr = W(x) # hide\nplot(r[:,:,1,2],title=\"convolved with x\")","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"Note that x has two extra dimensions; the second is the number of input channels and the third is the number of examples. The output r=W(x) has three extra dimensions, with the new dimension (the second one) varying over the filter. Because the default setting assumes periodic boundaries, we get a bleed-over, causing what should be exact replicas of the filters to give the difference between adjacent values. We can change the boundary conditions to address this, e.g. Pad(6)","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"julia> W = ConvFFT(ŵ,nothing,(128,1,2),boundary= FourierFilterFlux.Pad(6))\n┌ Warning: You didn't hand me a set of filters constructed with the boundary in mind. I'm going to adjust them to fit, this may not be what you intended\n└ @ FourierFilterFlux ~/allHail/projects/FourierFilterFlux/src/FourierFilterFlux.jl:148\nConvFFT[input=((128,), nfilters = 2, σ=identity, bc=Pad(6,)]\n\njulia> r =W(x); size(r)\n(128, 2, 1, 2)","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"W = ConvFFT(ŵ, nothing,(128,1,2),boundary= FourierFilterFlux.Pad(6)) # hide\nplot(r[:,:,1,2],title=\"convolved with x\")","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"and now we have a positive copy and a negative copy of each filter. For more details, see the Boundary Conditions section. If you want to start with some random filter, rather than constructing your own, there's a simple way to do that as well:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"julia> ex2Dsize = (127, 352, 1, 10);\n\njulia> filt = ConvFFT(ex2Dsize, 3, relu, trainable=true,bias=false)\nConvFFT[input=((127, 352), nfilters = 3, σ=relu, bc=Periodic()]\n","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"using FourierFilterFlux,Flux, Plots #hide\nex2Dsize = (127, 352, 1, 10); # hide\nfilt = ConvFFT(ex2Dsize, 3, relu, trainable=true,bias=false) # hide\nplot(heatmap(filt,dispReal=true,vis=1,colorbar=false,title=\"Filter 1\"),\n\theatmap(filt,dispReal=true,vis=2,colorbar=false,title=\"Filter 2\"),\n\theatmap(filt,dispReal=true,vis=3,colorbar=false, title=\"Filter 3\"),\n\tlayout=(1,3))","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"Here we've created a set of real weights represented in the Fourier domain. Now let's see if these filters can be fit to various lowpass filters:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"julia> using LinearAlgebra\n\njulia> fitThis = zeros(64,352,3); fitThis[1:3,(176-3:176+3),1] .= 1;\n\njulia> fitThis[1:15,(176-15:176+15),2] .= 1; fitThis[1:32,(176-44:176+44),3] .= 1;\n\njulia> targetConv = ConvFFT(fitThis, nothing, (127,352,1,10))\nConvFFT[input=((127, 352), nfilters = 3, σ=identity, bc=Periodic()]\n\njulia> sum(norm.(map(-, targetConv.weight, filt.weight)) .^ 2) / sum(norm.(targetConv.weight) .^ 2) # the relative error\n1.0038243395792357\n\njulia> loss(x,y) = norm(filt(x) - targetConv(x))\nloss (generic function with 1 method)\n\njulia> genEx(n) = [(cpu(randn(ex2Dsize)), true) for i=1:n];\n\njulia> Flux.train!(loss, Flux.params(filt), genEx(100), ADAM()) # train for 100 samples\n\njulia> sum(norm.(map(-, targetConv.weight, filt.weight)) .^ 2) / sum(norm.(targetConv.weight) .^ 2) # the relative error\n0.8206548516626784\n","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"using FourierFilterFlux, Flux, LinearAlgebra # hide\nfitThis = zeros(64,352,3); fitThis[1:3,(176-3:176+3),1] .= 1; # hide\nfitThis[1:15,(176-15:176+15),2] .= 1; fitThis[1:32,(176-44:176+44),3] .= 1; # hide\ntargetConv = ConvFFT(fitThis, nothing, (127,352,1,10)) # hide\nloss(x,y) = norm(filt(x) - targetConv(x)) # hide\ngenEx(n) = [(cpu(randn(ex2Dsize)), true) for i=1:n]; # hide\nFlux.train!(loss, Flux.params(filt), genEx(100), ADAM()) # hide\nloss(randn(ex2Dsize), nothing) # hide\nplot(heatmap(filt,vis=1), heatmap(filt,vis=2), heatmap(filt,vis=3),\n\theatmap(targetConv,vis=1), heatmap(targetConv,vis=2),\n\theatmap(targetConv,vis=3))","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"The top three are the fit filters, while the bottom three are the targets. So after 100 examples, we have something that passibly resembles the desired low-pass filters, though the relative error is still around 80%.","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"Finally, if you would rather be doing your computations on the gpu, simply use the gpu function of Flux.jl or cu of CUDA.jl:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"Wgpu = W |> gpu\nx = x |> gpu;\nWgpu(x)[:,1,1,1]'","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"\nConvFFT","category":"page"},{"location":"coreType/#FourierFilterFlux.ConvFFT","page":"Core Type","title":"FourierFilterFlux.ConvFFT","text":"# preconstructed filters w\nConvFFT(w::AbstractArray{T,N}, b, originalSize, σ = identity; plan=true,\nboundary = Periodic(), dType=Float32, trainable=true, OT=Float32, An=nothing)\n    where {T,N}\n# randomly constructed filters\nConvFFT(k::NTuple{N,Integer}, nOutputChannels = 5,\n        σ=identity; nConvDims=2, init = Flux.glorot_normal,\n        plan=true, bias = true,\n        dType=Float32, OT=Float32, boundary=Periodic(),\n        trainable=true, An=nothing) where N\n\nSimilar to Conv from Flux.jl, but does pointwise multiplication in the Fourier domain, with boundary conditions boundary, and applies the nonlinearity σ. It is worth noting that the bias is added in the Fourier domain; if you don't want a bias, set b=nothing. For the first method, the weights w should have dimension 1 greater than the size of the convolution, while for the second, k gives the size of the input (including channels and batch size), for which appropriate weights are generated in the fourier domain according to the distribution init.\n\nShared Arguments\n\nσ=identity: a function to apply.\ndType::DataType=Float32: the data type being input. By default, it assumes                           both the filter and the signal are real, which                           allows us to use an rfft and half the (complex)                           coefficients we would otherwise need.\nOT::DataType=Float32: the output datatype, usually determined by the (space                         domain) type of the filters. Currently assumes that                         if this is complex, then the filters are analytic                         (so only defined for positive frequencies).\nplan::Bool=true: use precomputed fft plan(s), as this is a significant cost.                    Set this to false if you have variable batch/channel sizes.\ntrainable::Bool=true: The entries are trainable as Flux objects, and so are                         returned in a params call if this is true.\nboundary::ConvBoundary: determines how the edges are treated. See e.g. Pad.\nAn::Union{Nothing,NTuple{<:Integer}}=nothing: only used if the output type is                   complex, so the filters are complex. In that case, it is a                   list of the filters which are actually real. This is                   included to allow for averaging wavelets which are real even                   for analytic wavelets. For both waveletLayer and                   shearingLayer, this is the last filter, so if there are                   18 total wavelets, An=(18,).\n\nFirst constructor only\n\nw::AbstractArray{T,N}: the weights. should be D+1, with the last                          dimension being the total number of filters\n\nb::Union{Nothing,AbstractArray}: ifnothing`, no bias is added. Otherwise it should be (input channels)×(output channels)\n\nSecond constructor only\n\nk::NTuple{N,Integer}: the dimensions of the input. In the 1D case it should                         be three entries e.g. (132,3,100) which is                         (signal)×(channels)×(examples). In the 2D case it                         should be four entries e.g. (132,132,3,100), which                         is (x)×(y)×(channels)×(examples).\nnOutputChannels::Integer=5: the number of filters to use.\nbias::Bool=true: determines whether or not to create a bias.\ninit::function=Flux.glorot_normal: The way to initialize both the bias (if                   defined) and the weights.  Any function that results in a                   matrix is allowed, though I would suggest something from                   Flux, or one of the ones defined in this package.\nnConvDims::Integer: the number of dimensions that we will be doing the                   convolution over, as k is somewhat ambiguous.\n\n\n\n\n\n","category":"type"},{"location":"coreType/#Plot-Recipe","page":"Core Type","title":"Plot Recipe","text":"","category":"section"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"To ease displaying the weights, we have a recipe that can be used with either plot or heatmap. First, we will generate some preconstructed 1D and 2D filters to demonstrate with:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"W1 = waveletLayer((256,1,5))\nW2 = ConvFFT((256,256),12,boundary=Sym());","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"The general form of the plot is","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"plot(cv::ConvFFT{N}; vis=1, dispReal=false, apply=abs, restrict=(Colon(), vis)) where {N}\n\nheatmap(cv::ConvFFT{N}; vis=1, dispReal=false, apply=abs, restrict=(Colon(), vis)) where {N}","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"The arguments are","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"vis=1: a structure identifying which filters you want to display. The default value is just the first one (displaying them one at a time makes more sense in the 2D case). It is worth noting that because these are created using a rfft, this is only the postive frequencies in the first dimension (vertical in the 2D shearlet plots and horizontal in the 1D plot).","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"plot(heatmap(W2,title=\"first filter\"), heatmap(W2,vis=4,title=\"Fourth filter\"))","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"plot(W1,vis=:,title=\"All of the Morlet Wavelets\")","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"dispReal::Bool=false: takes care of doing the correct type of fft to get the space domain filters centered; usually if this is used you also want to change\napply::Function=abs: from abs to the identity; the default of abs makes the most sense in the frequency domain. You probably also want to change\nrestrict=nothing: to show the plot only around the support of the filter:","category":"page"},{"location":"coreType/","page":"Core Type","title":"Core Type","text":"plot(heatmap(W2, dispReal=true,title= \"first wavelet space domain\"),\n     heatmap(W2, dispReal=true, restrict= (255:345,260:350), apply=identity,\n\t         title= \"first wavelet space domain \\nzoomed without abs\"))","category":"page"},{"location":"bound/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"There are various conditions one can choose from to deal with boundaries when taking a fft. ","category":"page"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"\noriginalSize\neffectiveSize","category":"page"},{"location":"bound/#FourierFilterFlux.originalSize","page":"Boundary Conditions","title":"FourierFilterFlux.originalSize","text":"originalSize(sz, boundary::ConvBoundary)\n\nGiven the size sz from the fft, return the size of the input.\n\n\n\n\n\n","category":"function"},{"location":"bound/#FourierFilterFlux.effectiveSize","page":"Boundary Conditions","title":"FourierFilterFlux.effectiveSize","text":"effectiveSize(sz, boundary::ConvBoundary)\n\nGiven the input size, figure out the resulting size\n\n\n\n\n\n","category":"function"},{"location":"bound/#Periodic","page":"Boundary Conditions","title":"Periodic","text":"","category":"section"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The simplest to implement, this just assumes that the two edges are adjacent boundary=Periodic(). ","category":"page"},{"location":"bound/#Pad{N}","page":"Boundary Conditions","title":"Pad{N}","text":"","category":"section"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The typical choice in convolutional neural networks, this assumes that the signal is zero beyond the values given. Currently, it is up to the user to figure out what the appropriate padding is; it is at worst the size of the space domain support of your filter. Suppose you have a 1D filter with 5 adjacent non-zero entries in the space domain, e.g.  w = [0..., 0, 5,1,-9,3,2, 0..., 0]; then the most carry-over that is possible is [2, 0..., 0, 5,1,-9,3], so if we pad with at least 5 zeros, then no entries will carry over. To do this, set boundary = Pad((5,)). You can choose larger paddings, of course, but you pay the price of a larger effective signal size. This can be chosen automatically by setting the padding amount to -1, e.g. boundary = Pad((-1,)).","category":"page"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"\nPad","category":"page"},{"location":"bound/#FourierFilterFlux.Pad","page":"Boundary Conditions","title":"FourierFilterFlux.Pad","text":"Pad(x::Vararg{<:Integer, N}) where N = Pad{N}(x)\n\nN gives the number of dimensions of convolution, while x gives the specific amount to pad in each dimension (done on both sides). If the values in x are negative, then the support of the filters will be determined automataically\n\n\n\n\n\n","category":"type"},{"location":"bound/#Symmetric","page":"Boundary Conditions","title":"Symmetric","text":"","category":"section"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"This is the assumption underlying the DCT type II[1] (Image: This is from Wikipedia https://commons.wikimedia.org/wiki/File:DCT-symmetries.svg)","category":"page"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"It assumes that the first and last value are repeated. This has two primary advantages: it makes the boundary continuous, and the derivative is less discontinuous than it would be with simply repeating the entries (as in the DCT type I above). The trade-off presently is that the implementation requires twice the space of the original image, which can be cost prohibitive.","category":"page"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"To use this boundary condition, just set boundary=Sym().","category":"page"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"[1]: This image is from wikipedia.","category":"page"},{"location":"init/#Initializations","page":"Initialization","title":"Initializations","text":"","category":"section"},{"location":"init/","page":"Initialization","title":"Initialization","text":"Beyond the standard initializations available in Flux there are a couple of new initializations available:","category":"page"},{"location":"init/","page":"Initialization","title":"Initialization","text":"positive_glorot_uniform\niden_perturbed_gaussian\nuniform_perturbed_gaussian","category":"page"},{"location":"init/#FourierFilterFlux.positive_glorot_uniform","page":"Initialization","title":"FourierFilterFlux.positive_glorot_uniform","text":"positive_glorot_uniform(dims...)\n\nsame idea as a glorot_uniform, but limited to strictly positive entries.\n\n\n\n\n\n","category":"function"},{"location":"init/#FourierFilterFlux.iden_perturbed_gaussian","page":"Initialization","title":"FourierFilterFlux.iden_perturbed_gaussian","text":"iden_perturbed_gaussian(dims...)\n\nan identity along the diagonal with Gaussian deviations of standard deviation frac 1 100 everywhere\n\n\n\n\n\n","category":"function"},{"location":"init/#FourierFilterFlux.uniform_perturbed_gaussian","page":"Initialization","title":"FourierFilterFlux.uniform_perturbed_gaussian","text":"uniform_perturbed_gaussian(dims...)\n\nIf there are n total entries in the matrix, each entry is gaussian distributed with a mean of ¹ₙ and a standard deviation of frac110n\n\n\n\n\n\n","category":"function"},{"location":"installation/#Installation","page":"Install","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Install","title":"Install","text":"At the moment this package is unregistered, so you will have to do it the hard way. Either press ] and run","category":"page"},{"location":"installation/","page":"Install","title":"Install","text":"(@v9.9) pkg> add https://github.com/dsweber2/FourierFilterFlux.jl.git","category":"page"},{"location":"installation/","page":"Install","title":"Install","text":"Alternatively, run","category":"page"},{"location":"installation/","page":"Install","title":"Install","text":"using Pkg\nPkg.add(\"https://github.com/dsweber2/FourierFilterFlux.jl.git\")","category":"page"},{"location":"#FourierFilterFlux-Documentation","page":"FourierFilterFlux Documentation","title":"FourierFilterFlux Documentation","text":"","category":"section"},{"location":"","page":"FourierFilterFlux Documentation","title":"FourierFilterFlux Documentation","text":"A package to convolve with your favorite filters in the frequency domain in 1,2, or 3 dimensions, and you are looking for them to be differentiable and/or computed using a gpu. This is most useful if your filters are reasonably large (more than around 100 entries total). Currently used in ScatteringTransform.jl and collatingTransform.jl The core is the ConvFFT type, for which there are a couple of Built-in constructors.","category":"page"},{"location":"","page":"FourierFilterFlux Documentation","title":"FourierFilterFlux Documentation","text":"","category":"page"},{"location":"#Index","page":"FourierFilterFlux Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"FourierFilterFlux Documentation","title":"FourierFilterFlux Documentation","text":"","category":"page"}]
}
