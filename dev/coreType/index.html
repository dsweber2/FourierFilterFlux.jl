<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Type · FourierFilterFlux.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FourierFilterFlux.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../installation/">Install</a></li><li><span class="tocitem">ConvFFT</span><ul><li class="is-active"><a class="tocitem" href>Core Type</a><ul class="internal"><li><a class="tocitem" href="#Plot-Recipe"><span>Plot Recipe</span></a></li></ul></li><li><a class="tocitem" href="../init/">Initialization</a></li><li><a class="tocitem" href="../bound/">Boundary Conditions</a></li></ul></li><li><a class="tocitem" href="../constructors/">Built-in Constructors</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ConvFFT</a></li><li class="is-active"><a href>Core Type</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Type</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dsweber2/FourierFilterFlux.jl/blob/master/docs/src/coreType.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>TODO: include notes about gpu usage</p><h1 id="ConvFFT-type"><a class="docs-heading-anchor" href="#ConvFFT-type">ConvFFT type</a><a id="ConvFFT-type-1"></a><a class="docs-heading-anchor-permalink" href="#ConvFFT-type" title="Permalink"></a></h1><p>The core type of this package. As a simple example in 1D:</p><pre><code class="language-julia">using FourierFilterFlux, Plots, FFTW, Flux, LinearAlgebra
w = zeros(128,2); w[25:30,1] = randn(6)
w[55:60,2] = randn(6)
ŵ = rfft(w, 1)
W = ConvFFT(ŵ,nothing,(128,1,2))
plot(W, title=&quot;Time domain Filters&quot;, dispReal=true,
     apply=identity, vis=1:2)</code></pre><pre class="documenter-example-output">/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</pre><p><img src="../randFilters.svg" alt/></p><p>So we&#39;ve created two filters with small support and displayed them in the time domain (note that this has been done with a <a href="#Plot-Recipe">Plot Recipe</a>). Applying this to a signal <code>x</code>, which is non-zero at only the two boundary locations:</p><pre><code class="language-julia-repl">julia&gt; x = zeros(128,1,2);

julia&gt; x[1,1,2] = 1; x[end,1,2] = -1; # positive on one side and negative on the other

julia&gt; r = W(x); size(r)
(128, 2, 1, 2)


/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../convolveWx.svg" alt/></p><p>Note that <code>x</code> has two extra dimensions; the second is the number of input channels and the third is the number of examples. The output <code>r=W(x)</code> has three extra dimensions, with the new dimension (the second one) varying over the filter. Because the default setting assumes periodic boundaries, we get a bleed-over, causing what should be exact replicas of the filters to give the difference between adjacent values. We can change the boundary conditions to address this, e.g. <code>Pad(6)</code></p><pre><code class="language-julia">W = ConvFFT(ŵ,nothing,(128,1,2),boundary= Pad(6))
r =W(x); size(r)</code></pre><pre class="documenter-example-output">┌ Warning: You didn&#39;t hand me a set of filters constructed with the boundary in mind. I&#39;m going to adjust them to fit, this may not be what you intended
└ @ FourierFilterFlux ~/build/dsweber2/FourierFilterFlux.jl/src/FourierFilterFlux.jl:129
/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</pre><p><img src="../convolveWxPad.svg" alt/></p><p>and now we have a positive copy and a negative copy of each filter. For more details, see the <a href="../bound/#Boundary-Conditions">Boundary Conditions</a> section. If you want to start with some random filter, rather than constructing your own, there&#39;s a simple way to do that as well:</p><pre><code class="language-julia-repl">
julia&gt; ex2Dsize = (127, 352, 1, 10);

julia&gt; filt = ConvFFT(ex2Dsize, 3, relu, trainable=true,bias=false)
ConvFFT[input=((127, 352), nfilters = 3, σ=relu, bc=Periodic()]

julia&gt; plot(heatmap(filt,dispReal=true,vis=1,colorbar=false,title=&quot;Filter 1&quot;),
       	heatmap(filt,dispReal=true,vis=2,colorbar=false,title=&quot;Filter 2&quot;),
       	heatmap(filt,dispReal=true,vis=3,colorbar=false, title=&quot;Filter 3&quot;),
       	layout=(1,3))
Plot{Plots.GRBackend() n=3}

/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../2Dfilts.svg" alt/></p><p>Here we&#39;ve created a set of real weights represented in the Fourier domain. Now  let&#39;s see if these filters can be fit to various lowpass filters:</p><pre><code class="language-julia">fitThis = zeros(64,352,3); fitThis[1:3,(176-3:176+3),1] .= 1;
fitThis[1:15,(176-15:176+15),2] .= 1; fitThis[1:32,(176-44:176+44),3] .= 1;
targetConv = ConvFFT(fitThis, nothing, (127,352,1,10))
loss(x,y) = norm(filt(x) - targetConv(x))
genEx(n) = [(cpu(randn(ex2Dsize)), true) for i=1:n];
Flux.train!(loss, params(filt), genEx(100), ADAM())
plot(heatmap(filt,vis=1), heatmap(filt,vis=2), heatmap(filt,vis=3),
	heatmap(targetConv,vis=1), heatmap(targetConv,vis=2),
	heatmap(targetConv,vis=3))</code></pre><pre class="documenter-example-output">/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</pre><p><img src="../fitting2Dfilts.svg" alt/></p><p>The top three are the fit filters, while the bottom three are the targets. So after 100 examples, we have something that passibly resembles the desired low-pass filters, though not yet matching the norm. Finally, if you would rather be doing your computations on the gpu, simply use the <code>gpu</code> function of Flux.jl or <code>cu</code> of CUDA.jl:</p><pre><code class="language-julia-repl">julia&gt; Wgpu = W |&gt; gpu
ConvFFT[input=((128,), nfilters = 2, σ=identity, bc=Pad(6,)]

julia&gt; x = x |&gt; gpu;

julia&gt; Wgpu(x)[:,1,1,1]&#39;
1×128 LinearAlgebra.Adjoint{Float32,Array{Float32,1}}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><article class="docstring"><header><a class="docstring-binding" id="FourierFilterFlux.ConvFFT" href="#FourierFilterFlux.ConvFFT"><code>FourierFilterFlux.ConvFFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"># preconstructed filters w
ConvFFT(w::AbstractArray{T,N}, b, originalSize, σ = identity; plan=true, 
boundary = Periodic(), dType=Float32, trainable=true, OT=Float32, An=nothing) 
    where {T,N}
# randomly constructed filters
ConvFFT(k::NTuple{N,Integer}, nOutputChannels = 5,
        σ=identity; nConvDims=2, init = Flux.glorot_normal,
        plan=true, bias = true,
        dType=Float32, OT=Float32, boundary=Periodic(), 
        trainable=true, An=nothing) where N</code></pre><p>Similar to <code>Conv</code> from Flux.jl, but does pointwise multiplication in the Fourier domain, with boundary conditions <code>boundary</code>, and applies the nonlinearity <code>σ</code>. It is worth noting that the bias is added in the Fourier domain; if you don&#39;t want a bias, set <code>b=nothing</code>. For the first method, the weights <code>w</code> should have dimension 1 greater than the size of the convolution, while for the second, <code>k</code> gives the size of the input (including channels and batch size), for which appropriate weights are generated in the fourier domain according to the distribution <code>init</code>.</p><p><strong>Shared Arguments</strong></p><ul><li><code>σ=identity</code>: a function to apply.</li><li><code>dType::DataType=Float32</code>: the data type being input. By default, it assumes                            both the filter and the signal are real, which                            allows us to use an rfft and half the (complex)                           coefficients we would otherwise need.</li><li><code>OT::DataType=Float32</code>: the output datatype, usually determined by the (space                         domain) type of the filters. Currently assumes that                          if this is complex, then the filters are analytic                          (so only defined for positive frequencies).</li><li><code>plan::Bool=true</code>: use precomputed fft plan(s), as this is a significant cost.                    Set this to <code>false</code> if you have variable batch/channel sizes.</li><li><code>trainable::Bool=true</code>: The entries are trainable as Flux objects, and so are                          returned in a <code>params</code> call if this is <code>true</code>.</li><li><code>boundary::ConvBoundary</code>: determines how the edges are treated. See e.g. <code>Pad</code>.</li><li><code>An::Union{Nothing,NTuple{&lt;:Integer}}=nothing</code>: only used if the output type is                    complex, so the filters are complex. In that case, it is a                    list of the filters which are actually real. This is                    included to allow for averaging wavelets which are real even                   for analytic wavelets. For both <code>waveletLayer</code> and                    <code>shearingLayer</code>, this is the last filter, so if there are                   18 total wavelets, <code>An=(18,)</code>.</li></ul><p><strong>First constructor only</strong></p><ul><li><code>w::AbstractArray{T,N}</code>: the weights. should be <code>D+1</code>, with the last                          dimension being the total number of filters</li></ul><p><code></code>b::Union{Nothing,AbstractArray}<code>: if</code>nothing`, no bias is added. Otherwise it should be (input channels)×(output channels) </p><p><strong>Second constructor only</strong></p><ul><li><p><code>k::NTuple{N,Integer}</code>: the dimensions of the input. In the 1D case it should                         be three entries e.g. <code>(132,3,100)</code> which is                         (signal)×(channels)×(examples). In the 2D case it                         should be four entries e.g. <code>(132,132,3,100)</code>, which                         is (x)×(y)×(channels)×(examples).</p></li><li><p><code>nOutputChannels::Integer=5</code>: the number of filters to use.</p></li><li><p><code>bias::Bool=true</code>: determines whether or not to create a bias.</p></li><li><p><code>init::function=Flux.glorot_normal</code>: The way to initialize both the bias (if                   defined) and the weights.  Any function that results in a                   matrix is allowed, though I would suggest something from                   Flux, or one of the ones defined in this package.</p></li><li><p><code>nConvDims::Integer</code>: the number of dimensions that we will be doing the                   convolution over, as <code>k</code> is somewhat ambiguous.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dsweber2/FourierFilterFlux.jl/blob/0886344f0cebbcecb0ff13060fd21e765074f0a1/src/FourierFilterFlux.jl#L29-L91">source</a></section></article><h2 id="Plot-Recipe"><a class="docs-heading-anchor" href="#Plot-Recipe">Plot Recipe</a><a id="Plot-Recipe-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Recipe" title="Permalink"></a></h2><p>To ease displaying the weights, we have a <a href="https://docs.juliaplots.org/latest/recipes/">recipe</a> that can be used with either <code>plot</code> or <code>heatmap</code>. First, we will generate some preconstructed 1D and 2D filters to demonstrate with:</p><pre><code class="language-julia">W1 = waveletLayer((256,1,5))
W2 = shearingLayer((256,256));</code></pre><pre class="documenter-example-output">ConvFFT[input=((256, 256), nfilters = 49, σ=abs, bc=Pad(168, 176)]</pre><p>The general form of the plot is</p><pre><code class="language-none">plot(cv::ConvFFT{N}; vis=1, dispReal=false, apply=abs, restrict=(Colon(), vis)) where {N}

heatmap(cv::ConvFFT{N}; vis=1, dispReal=false, apply=abs, restrict=(Colon(), vis)) where {N}</code></pre><p>The arguments are</p><ul><li><code>vis=1</code>: a structure identifying which filters you want to display. The default value is just the first one (displaying them one at a time makes more sense in the 2D case). It is worth noting that because these are created using a rfft, this is only the postive frequencies in the first dimension (vertical in the 2D shearlet plots and horizontal in the 1D plot).</li></ul><pre><code class="language-julia">plot(heatmap(W2,title=&quot;first shearlet&quot;), heatmap(W2,vis=4,title=&quot;Fourth shearlet&quot;))
plot(W1,vis=:,title=&quot;All of the Morlet Wavelets&quot;)</code></pre><pre class="documenter-example-output">/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS
/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</pre><p><img src="../demoVis.svg" alt/>   <img src="../demoVis1D.svg" alt/></p><ul><li><code>dispReal::Bool=false</code>: takes care of doing the correct type of fft to get the space domain filters centered; usually if this is used you also want to change</li><li><code>apply::Function=abs</code>: from <code>abs</code> to the identity; the default of <code>abs</code> makes the most sense in the frequency domain. You probably also want to change</li><li><code>restrict=nothing</code>: to show the plot only around the support of the filter:</li></ul><pre><code class="language-julia">plot(heatmap(W2, dispReal=true,title= &quot;first wavelet space domain&quot;),
     heatmap(W2, dispReal=true, restrict= (255:345,260:350), apply=identity,
	         title= &quot;first wavelet space domain \nzoomed without abs&quot;));</code></pre><pre class="documenter-example-output">/home/travis/.julia/packages/GR/BwGt2/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</pre><p><img src="../zooming.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">« Install</a><a class="docs-footer-nextpage" href="../init/">Initialization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 29 September 2020 23:21">Tuesday 29 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
